#include "rclcpp/rclcpp.hpp"

// automatically generated by ROS 2
// path is <workspace>/install/tm_msgs/include/tm_msgs/srv/set_positions.hpp
#include "tm_msgs/srv/set_positions.hpp"

#include <chrono>
#include <cstdlib>
#include <memory>
#include <termios.h>
#include <iostream>
#include <unistd.h>

using namespace std::chrono_literals;

void init_keyboard()
{
    termios term;
    tcgetattr(STDIN_FILENO, &term);
    term.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &term);
}

void restore_keyboard()
{
    termios term;
    tcgetattr(STDIN_FILENO, &term);
    term.c_lflag |= (ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &term);
}

int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    auto node = rclcpp::Node::make_shared("keyboard_control"); // create node
    auto client = node->create_client<tm_msgs::srv::SetPositions>("set_positions"); // create client
    auto request = std::make_shared<tm_msgs::srv::SetPositions::Request>(); // create request

    // default configuration for PTP_T
    request->motion_type = tm_msgs::srv::SetPositions::Request::PTP_T;
    request->velocity = 0.5;       // Relative velocity
    request->acc_time = 0.2;       // Acceleration time in seconds
    request->blend_percentage = 0; // No blending
    request->fine_goal = true;     // Precisely reach the goal

    // Initial Cartesian position (X, Y, Z) and orientation (RX, RY, RZ)
    request->positions = {0.0, 0.0, 0.0, 0.0, 0.2, 0.0};

    // check and wait until service available
    while (!client->wait_for_service(1s))
    {
        if (!rclcpp::ok())
        {
            RCLCPP_ERROR_STREAM(rclcpp::get_logger("rclcpp"), "Interrupted while waiting for the service. Exiting.");
            return 1; // error exit
        }
        RCLCPP_INFO_STREAM(rclcpp::get_logger("rclcpp"), "Service not available, waiting again...");
    }

    // Initial service call to move to home position
    auto result = client->async_send_request(request);
    if (rclcpp::spin_until_future_complete(node, result) == rclcpp::FutureReturnCode::SUCCESS)
    {
        if (result.get()->ok)
        {
            RCLCPP_INFO_STREAM(rclcpp::get_logger("rclcpp"), "Moved to initial position.");
        }
        else
        {
            RCLCPP_ERROR_STREAM(rclcpp::get_logger("rclcpp"), "Failed to execute the initial position.");
        }
    }
    else
    {
        RCLCPP_ERROR_STREAM(rclcpp::get_logger("rclcpp"), "Failed to call service.");
        rclcpp::shutdown();
        return 1;
    }

    // keyboard input
    init_keyboard();
    char c;
    bool running = true;
    std::cout << "Use 'w', 'a', 's', 'd', 'r', 'f' to control the robot arm in Cartesian space, 'q' to quit." << std::endl;
    auto last_time = std::chrono::steady_clock::now();

    while (running && rclcpp::ok())
    {
        if (read(STDIN_FILENO, &c, 1) > 0)
        {
            auto current_time = std::chrono::steady_clock::now();
            if (std::chrono::duration_cast<std::chrono::milliseconds>(current_time - last_time).count() > 200)
            {
                switch (c)
                {
                    case 'w':
                        request->positions[1] += 0.01; // Y-axis increase
                        break;

                    case 's':
                        request->positions[1] -= 0.01; // Y-axis decrease
                        break;

                    case 'a':
                        request->positions[0] -= 0.01; // X-axis decrease
                        break;

                    case 'd':
                        request->positions[0] += 0.01; // X-axis increase
                        break;

                    case 'r':
                        request->positions[2] += 0.01; // Z-axis increase
                        break;

                    case 'f':
                        request->positions[2] -= 0.01; // Z-axis decrease
                        break;

                    case 'q':
                        running = false;
                        break;

                    default:
                        break;
                }

                // Send the updated request
                auto result = client->async_send_request(request);
                rclcpp::spin_some(node);
                if (rclcpp::spin_until_future_complete(node, result) == rclcpp::FutureReturnCode::SUCCESS)
                {
                    if (result.get()->ok)
                    {
                        RCLCPP_INFO_STREAM(rclcpp::get_logger("rclcpp"), "Command executed successfully.");
                    }
                    else
                    {
                        RCLCPP_ERROR_STREAM(rclcpp::get_logger("rclcpp"), "Command execution failed.");
                    }
                }
                else
                {
                    RCLCPP_ERROR_STREAM(rclcpp::get_logger("rclcpp"), "Failed to call service.");
                    restore_keyboard();
                    rclcpp::shutdown();
                    return 1;
                }

                last_time = current_time;
            }
        }
    }

    restore_keyboard();
    rclcpp::shutdown();
    return 0;
}