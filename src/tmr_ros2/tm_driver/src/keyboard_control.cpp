// #include "rclcpp/rclcpp.hpp"

// // automatically generated by ROS 2
// // path is <workspace>/install/tm_msgs/include/tm_msgs/srv/set_positions.hpp
// #include "tm_msgs/srv/set_positions.hpp"

// #include <chrono>
// #include <cstdlib>
// #include <memory>
// #include <termios.h>  // for keyboard input
// #include <iostream>
// #include <unistd.h>

// using namespace std::chrono_literals;

// void init_keyboard()
// {
//     termios term; // Structure to store terminal attributes
//     tcgetattr(STDIN_FILENO, &term); // Get the current terminal attributes and store them in 'term'
//     term.c_lflag &= ~(ICANON | ECHO); // Disable line buffering (ICANON) and input echoing (ECHO)
//     tcsetattr(STDIN_FILENO, TCSANOW, &term); // Apply the modified attributes immediately
// }

// // Restore the keyboard input mode: enable line buffering and input echo
// void restore_keyboard()
// {
//     termios term; // Structure to store terminal attributes
//     tcgetattr(STDIN_FILENO, &term); // Get the current terminal attributes and store them in 'term'
//     term.c_lflag |= (ICANON | ECHO); // Enable line buffering (ICANON) and input echoing (ECHO)
//     tcsetattr(STDIN_FILENO, TCSANOW, &term); // Apply the modified attributes immediately
// }


// int main(int argc, char **argv)
// {
//     rclcpp::init(argc, argv);
//     auto node = rclcpp::Node::make_shared("keyboard_control"); // create node
//     auto client = node->create_client<tm_msgs::srv::SetPositions>("set_positions"); // create client
//     auto request = std::make_shared<tm_msgs::srv::SetPositions::Request>(); // create request

//     // default configuration
//     request->motion_type = tm_msgs::srv::SetPositions::Request::PTP_J;
//     request->velocity = 1;
//     request->acc_time = 0.2;
//     request->blend_percentage = 10;
//     request->fine_goal = true;
//     request->positions.push_back(-0.7854);
//     request->positions.push_back(0);
//     request->positions.push_back(1.5708);
//     request->positions.push_back(0);
//     request->positions.push_back(1.5708);
//     request->positions.push_back(0);

//     // check and wait until service available
//     while(!client->wait_for_service(1s))
//     {
//         if(!rclcpp::ok())
//         {
//             RCLCPP_ERROR_STREAM(rclcpp::get_logger("rclcpp"), "Interrupted while waiting for the service. Exiting.");
//             return 1; // error exit
//         }
//         RCLCPP_INFO_STREAM(rclcpp::get_logger("rclcpp"), "service not available, waiting again...");
//     }

//     // default service call(back to home position)
//     auto result = client->async_send_request(request);
//     // wait for the result
//     if(rclcpp::spin_until_future_complete(node, result) ==  rclcpp::FutureReturnCode::SUCCESS)
//     {
//         if(result.get()->ok)
//         {
//             RCLCPP_INFO_STREAM(rclcpp::get_logger("rclcpp"), "Success");
//         }
//         else // request send to server but failed in execution
//         {
//             RCLCPP_ERROR_STREAM(rclcpp::get_logger("rclcpp"), "Failed");
//         }   
//     }
//     else // request failed to send to server
//     {
//         RCLCPP_ERROR_STREAM(rclcpp::get_logger("rclcpp"), "Failed to call service");
//         rclcpp::shutdown();
//         return 1; // error exit 
//     }

//     // keyboard input
//     init_keyboard();
//     char c;
//     bool running = true;
//     std::cout << "Use 'w', 'a', 's', 'd' to control the robot arm, 'q' to quit." << std::endl;
//     auto last_time = std::chrono::steady_clock::now();

//     const double J1_MIN = -4.7124; // Joint 1: -270° in radians
//     const double J1_MAX =  4.7124; // Joint 1:  270° in radians

//     const double J2_MIN = -3.1416; // Joint 2: -180° in radians
//     const double J2_MAX =  3.1416; // Joint 2:  180° in radians

//     const double J3_MIN = -2.7053; // Joint 3: -155° in radians
//     const double J3_MAX =  2.7053; // Joint 3:  155° in radians

//     const double J4_MIN = -3.1416; // Joint 4: -180° in radians
//     const double J4_MAX =  3.1416; // Joint 4:  180° in radians

//     const double J5_MIN = -3.1416; // Joint 5: -180° in radians
//     const double J5_MAX =  3.1416; // Joint 5:  180° in radians

//     const double J6_MIN = -4.7124; // Joint 6: -270° in radians
//     const double J6_MAX =  4.7124; // Joint 6:  270° in radians
//     while (running && rclcpp::ok())
//     {
//         if (read(STDIN_FILENO, &c, 1) > 0) 
//         {
//             auto current_time = std::chrono::steady_clock::now();
//             if (std::chrono::duration_cast<std::chrono::milliseconds>(current_time - last_time).count() > 200)
//             {
//                 switch (c)
//                 {
//                     case 'w':
//                         if(request->positions[0] + 0.03 < J1_MAX)
//                         {
//                             request->positions[0] += 0.03;
//                         }
//                         else
//                         {
//                             RCLCPP_WARN_STREAM(rclcpp::get_logger("rclcpp"), "Joint 1 is at its maximum limit.");
//                         }
//                         break;

//                     case 's':
//                         if(request->positions[0] - 0.03 > J1_MIN)
//                         {
//                             request->positions[0] -= 0.03;
//                         }
//                         else
//                         {
//                             RCLCPP_WARN_STREAM(rclcpp::get_logger("rclcpp"), "Joint 1 is at its minimum limit.");
//                         }
//                         break;

//                     case 'a':
//                         if(request->positions[1] + 0.03 < J2_MAX)
//                         {
//                             request->positions[1] += 0.03;
//                         }
//                         else
//                         {
//                             RCLCPP_WARN_STREAM(rclcpp::get_logger("rclcpp"), "Joint 2 is at its maximum limit.");
//                         }
//                         break;

//                     case 'd':
//                         if(request->positions[1] - 0.03 > J2_MIN)
//                         {
//                             request->positions[1] -= 0.03;
//                         }
//                         else
//                         {
//                             RCLCPP_WARN_STREAM(rclcpp::get_logger("rclcpp"), "Joint 2 is at its minimum limit.");
//                         }
//                         break;

//                     case 'q':
//                         running = false;
//                         break;

//                     default:
//                         break;
//                 }
//                 last_time = current_time;
//                 auto result = client->async_send_request(request);
//                 rclcpp::spin_some(node);
//                 if(rclcpp::spin_until_future_complete(node, result) ==  rclcpp::FutureReturnCode::SUCCESS)
//                 {
//                     if(result.get()->ok)
//                     {
//                         RCLCPP_INFO_STREAM(rclcpp::get_logger("rclcpp"), "Success");
//                     }
//                     else // request send to server but failed in execution
//                     {
//                         RCLCPP_ERROR_STREAM(rclcpp::get_logger("rclcpp"), "Failed");
//                     }   
//                 }
//                 else // request failed to send to server
//                 {
//                     RCLCPP_ERROR_STREAM(rclcpp::get_logger("rclcpp"), "Failed to call service");
//                     restore_keyboard();
//                     rclcpp::shutdown();
//                     return 1; // error exit 
//                 }
//             }
//         }
        
//         //rclcpp::spin_some(node);
//     }

//     restore_keyboard();
//     rclcpp::shutdown();
//     return 0;

// }

#include "rclcpp/rclcpp.hpp"

// automatically generated by ROS 2
// path is <workspace>/install/tm_msgs/include/tm_msgs/srv/set_positions.hpp
#include "tm_msgs/srv/set_positions.hpp"

#include <chrono>
#include <cstdlib>
#include <memory>
#include <termios.h>  // for keyboard input
#include <iostream>
#include <unistd.h>

using namespace std::chrono_literals;

void init_keyboard()
{
    termios term; // Structure to store terminal attributes
    tcgetattr(STDIN_FILENO, &term); // Get the current terminal attributes and store them in 'term'
    term.c_lflag &= ~(ICANON | ECHO); // Disable line buffering (ICANON) and input echoing (ECHO)
    tcsetattr(STDIN_FILENO, TCSANOW, &term); // Apply the modified attributes immediately
}

// Restore the keyboard input mode: enable line buffering and input echo
void restore_keyboard()
{
    termios term; // Structure to store terminal attributes
    tcgetattr(STDIN_FILENO, &term); // Get the current terminal attributes and store them in 'term'
    term.c_lflag |= (ICANON | ECHO); // Enable line buffering (ICANON) and input echoing (ECHO)
    tcsetattr(STDIN_FILENO, TCSANOW, &term); // Apply the modified attributes immediately
}


int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    auto node = rclcpp::Node::make_shared("keyboard_control"); // create node
    auto client = node->create_client<tm_msgs::srv::SetPositions>("set_positions"); // create client
    auto request = std::make_shared<tm_msgs::srv::SetPositions::Request>(); // create request

    // default configuration
    request->motion_type = tm_msgs::srv::SetPositions::Request::PTP_J;
    request->velocity = 1;
    request->acc_time = 0.2;
    request->blend_percentage = 10;
    request->fine_goal = true;
    request->positions.push_back(-0.7854);
    request->positions.push_back(0);
    request->positions.push_back(1.5708);
    request->positions.push_back(0);
    request->positions.push_back(1.5708);
    request->positions.push_back(0);

    // check and wait until service available
    while(!client->wait_for_service(1s))
    {
        if(!rclcpp::ok())
        {
            RCLCPP_ERROR_STREAM(rclcpp::get_logger("rclcpp"), "Interrupted while waiting for the service. Exiting.");
            return 1; // error exit
        }
        RCLCPP_INFO_STREAM(rclcpp::get_logger("rclcpp"), "service not available, waiting again...");
    }

    // default service call(back to home position)
    auto result = client->async_send_request(request);
    // wait for the result
    if(rclcpp::spin_until_future_complete(node, result) ==  rclcpp::FutureReturnCode::SUCCESS)
    {
        if(result.get()->ok)
        {
            RCLCPP_INFO_STREAM(rclcpp::get_logger("rclcpp"), "Success");
        }
        else // request send to server but failed in execution
        {
            RCLCPP_ERROR_STREAM(rclcpp::get_logger("rclcpp"), "Failed");
        }   
    }
    else // request failed to send to server
    {
        RCLCPP_ERROR_STREAM(rclcpp::get_logger("rclcpp"), "Failed to call service");
        rclcpp::shutdown();
        return 1; // error exit 
    }

    // keyboard input
    init_keyboard();
    char c;
    bool running = true;
    std::cout << "Use 'qa', 'ws', 'ed', 'rf', 'tg', 'yh' to control the robot arm joints, 'z' to quit." << std::endl;
    auto last_time = std::chrono::steady_clock::now();

    const double J1_MIN = -4.7124; // Joint 1: -270° in radians
    const double J1_MAX =  4.7124; // Joint 1:  270° in radians

    const double J2_MIN = -3.1416; // Joint 2: -180° in radians
    const double J2_MAX =  3.1416; // Joint 2:  180° in radians

    const double J3_MIN = -2.7053; // Joint 3: -155° in radians
    const double J3_MAX =  2.7053; // Joint 3:  155° in radians

    const double J4_MIN = -3.1416; // Joint 4: -180° in radians
    const double J4_MAX =  3.1416; // Joint 4:  180° in radians

    const double J5_MIN = -3.1416; // Joint 5: -180° in radians
    const double J5_MAX =  3.1416; // Joint 5:  180° in radians

    const double J6_MIN = -4.7124; // Joint 6: -270° in radians
    const double J6_MAX =  4.7124; // Joint 6:  270° in radians

    while (running && rclcpp::ok())
    {
        if (read(STDIN_FILENO, &c, 1) > 0) 
        {
            auto current_time = std::chrono::steady_clock::now();
            if (std::chrono::duration_cast<std::chrono::milliseconds>(current_time - last_time).count() > 200)
            {
                switch (c)
                {
                    case 'q':
                        if(request->positions[0] + 0.03 < J1_MAX)
                        {
                            request->positions[0] += 0.03;
                        }
                        else
                        {
                            RCLCPP_WARN_STREAM(rclcpp::get_logger("rclcpp"), "Joint 1 is at its maximum limit.");
                        }
                        break;

                    case 'a':
                        if(request->positions[0] - 0.03 > J1_MIN)
                        {
                            request->positions[0] -= 0.03;
                        }
                        else
                        {
                            RCLCPP_WARN_STREAM(rclcpp::get_logger("rclcpp"), "Joint 1 is at its minimum limit.");
                        }
                        break;

                    case 'w':
                        if(request->positions[1] + 0.03 < J2_MAX)
                        {
                            request->positions[1] += 0.03;
                        }
                        else
                        {
                            RCLCPP_WARN_STREAM(rclcpp::get_logger("rclcpp"), "Joint 2 is at its maximum limit.");
                        }
                        break;

                    case 's':
                        if(request->positions[1] - 0.03 > J2_MIN)
                        {
                            request->positions[1] -= 0.03;
                        }
                        else
                        {
                            RCLCPP_WARN_STREAM(rclcpp::get_logger("rclcpp"), "Joint 2 is at its minimum limit.");
                        }
                        break;

                    case 'e':
                        if(request->positions[2] + 0.03 < J3_MAX)
                        {
                            request->positions[2] += 0.03;
                        }
                        else
                        {
                            RCLCPP_WARN_STREAM(rclcpp::get_logger("rclcpp"), "Joint 3 is at its maximum limit.");
                        }
                        break;

                    case 'd':
                        if(request->positions[2] - 0.03 > J3_MIN)
                        {
                            request->positions[2] -= 0.03;
                        }
                        else
                        {
                            RCLCPP_WARN_STREAM(rclcpp::get_logger("rclcpp"), "Joint 3 is at its minimum limit.");
                        }
                        break;

                    case 'r':
                        if(request->positions[3] + 0.03 < J4_MAX)
                        {
                            request->positions[3] += 0.03;
                        }
                        else
                        {
                            RCLCPP_WARN_STREAM(rclcpp::get_logger("rclcpp"), "Joint 4 is at its maximum limit.");
                        }
                        break;

                    case 'f':
                        if(request->positions[3] - 0.03 > J4_MIN)
                        {
                            request->positions[3] -= 0.03;
                        }
                        else
                        {
                            RCLCPP_WARN_STREAM(rclcpp::get_logger("rclcpp"), "Joint 4 is at its minimum limit.");
                        }
                        break;

                    case 't':
                        if(request->positions[4] + 0.03 < J5_MAX)
                        {
                            request->positions[4] += 0.03;
                        }
                        else
                        {
                            RCLCPP_WARN_STREAM(rclcpp::get_logger("rclcpp"), "Joint 5 is at its maximum limit.");
                        }
                        break;

                    case 'g':
                        if(request->positions[4] - 0.03 > J5_MIN)
                        {
                            request->positions[4] -= 0.03;
                        }
                        else
                        {
                            RCLCPP_WARN_STREAM(rclcpp::get_logger("rclcpp"), "Joint 5 is at its minimum limit.");
                        }
                        break;

                    case 'y':
                        if(request->positions[5] + 0.03 < J6_MAX)
                        {
                            request->positions[5] += 0.03;
                        }
                        else
                        {
                            RCLCPP_WARN_STREAM(rclcpp::get_logger("rclcpp"), "Joint 6 is at its maximum limit.");
                        }
                        break;

                    case 'h':
                        if(request->positions[5] - 0.03 > J6_MIN)
                        {
                            request->positions[5] -= 0.03;
                        }
                        else
                        {
                            RCLCPP_WARN_STREAM(rclcpp::get_logger("rclcpp"), "Joint 6 is at its minimum limit.");
                        }
                        break;

                    case 'z':
                        running = false;
                        break;

                    default:
                        break;
                }
                last_time = current_time;
                auto result = client->async_send_request(request);
                rclcpp::spin_some(node);
                if(rclcpp::spin_until_future_complete(node, result) ==  rclcpp::FutureReturnCode::SUCCESS)
                {
                    if(result.get()->ok)
                    {
                        RCLCPP_INFO_STREAM(rclcpp::get_logger("rclcpp"), "Success");
                    }
                    else // request send to server but failed in execution
                    {
                        RCLCPP_ERROR_STREAM(rclcpp::get_logger("rclcpp"), "Failed");
                    }   
                }
                else // request failed to send to server
                {
                    RCLCPP_ERROR_STREAM(rclcpp::get_logger("rclcpp"), "Failed to call service");
                    restore_keyboard();
                    rclcpp::shutdown();
                    return 1; // error exit 
                }
            }
        }
        
        //rclcpp::spin_some(node);
    }

    restore_keyboard();
    rclcpp::shutdown();
    return 0;

}
